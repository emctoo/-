#include <stdint.h>
#include <stdio.h>

#include <iostream>

#include <QString>

// 接收到的字节, gb18030编码的, 要转换成utf8的
uint8_t bytes[] = {
	0x52, 0x45, 0x54, 0x52, 0x20, 0x2f, 0x70, 0x75, 0x62, 0x2f, 0x6d, 0x79, 0x74,
	0x6f, 0x6f, 0x6c, 0x73, 0x2f, 0x66, 0x69, 0x6c, 0x6d, 0x2f, 0xc1, 0xfa, 0xce,
	0xc6, 0xc9, 0xed, 0xb5, 0xc4, 0xc5, 0xae, 0xba, 0xa2, 0x2e, 0x54, 0x68, 0x65,
	0x2e, 0x47, 0x69, 0x72, 0x6c, 0x2e, 0x57, 0x69, 0x74, 0x68, 0x2e, 0x54, 0x68,
	0x65, 0x2e, 0x44, 0x72, 0x61, 0x67, 0x6f, 0x6e, 0x2e, 0x54, 0x61, 0x74, 0x74,
	0x6f, 0x6f, 0x2e, 0x32, 0x30, 0x30, 0x39, 0x2e, 0x42, 0x44, 0x2d, 0x52, 0x4d,
	0x56, 0x42, 0x2d, 0xc8, 0xcb, 0xc8, 0xcb, 0xd3, 0xb0, 0xca, 0xd3, 0xd4, 0xad,
	0xb4, 0xb4, 0xb7, 0xad, 0xd2, 0xeb, 0xd6, 0xd0, 0x25, 0x2e, 0x72, 0x6d, 0x76,
	0x62, 0x00}; // 添加了0结尾

void dump_cstring_bytes(const char *bytes, size_t sz) {
    printf("**** **** **** ***\n");
    printf("[%.*s]\n", (int)sz, bytes);
    for (size_t nth = 0; nth < sz; ++nth) {
        printf("%x, ", (uint8_t)bytes[nth]);
    }
    putchar('\n');
}

void working(uint8_t *input_bytes, size_t size, char *output) {
}

int main(void) {
	char output[1024] = "";
	working(bytes, sizeof(bytes), output);

	size_t length = sizeof(bytes);

	std::cout << "length: " << length << '\n';
	std::cout << bytes << '\n';

	for (size_t nth = 0; nth < length; ++nth) {
		printf("%x, ", bytes[nth]);
	}
	putchar('\n');

	printf("--------------------------------\n");

	char *s = reinterpret_cast<char *>(bytes);
	for (size_t nth = 0; nth < length; ++nth) {
		printf("%x, ", s[nth] > 0 ? s[nth] : 128 - s[nth]);
	}
	putchar('\n');

    QString S = QString::fromLocal8Bit(s, length).trimmed();
    std::cout << S.toStdString() << '\n';

    std::string command = S.toStdString();

    char *input_bytes = const_cast<char *>(command.c_str());
    dump_cstring_bytes(input_bytes, command.size());
	return 0;
}
